<!DOCTYPE html>
<html lang="en">
<head>
    <title>System Status</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../shared/styles.css">
</head>
<body>
    <div class="blob blob-1"></div>
    <div class="blob blob-2"></div>

    <div class="content">
        <div class="glass-card">
    
                      <h1 class="form-title"><img src="../shared/logo.webp" alt="Logo" style="vertical-align: middle; margin-right: 15px; width: 50px;">q0wqexray</h1>
            
            <!-- Контейнер для мониторов -->
            <div id="monitors-container" style="width: 100%; max-width: 800px;"></div>
            
        </div>

    </div>
    
    <script>
        // Массив API-ключей для использования
        const apiKeys = ['m801955062-f06523a4ac30ca0d4d1ce04f', 'm801957293-ea8ef3a7185db5f5de8fe8d5'];
        
        // Функция для получения исторических данных монитора
        // Вместо getMonitorLogs используем getMonitors с дополнительными параметрами
        async function getMonitorHistory(apiKey, monitorId, startDate, endDate) {
            console.log('Попытка получения истории для монитора:', monitorId);
            console.log('Используем getMonitors с параметрами для получения логов');
            
            // Вместо getMonitorLogs, используем getMonitors с параметром logs=1
            const response = await fetch('https://api.uptimerobot.com/v2/getMonitors', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `api_key=${encodeURIComponent(apiKey)}&format=json&logs=1&monitor_ids=u${monitorId}`
            });
            
            console.log('Ответ от сервера:', response.status, response.statusText);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            console.log('Данные истории получены:', data);
            
            // Извлекаем логи из ответа
            if (data.monitors && data.monitors.length > 0 && data.monitors[0].logs) {
                // Фильтруем логи по диапазону дат
                const filteredLogs = data.monitors[0].logs.filter(log =>
                    log.datetime >= startDate && log.datetime <= endDate
                );
                return filteredLogs;
            }
            return [];
        }
        
        // Функция для получения мониторов с одного API-ключа
        async function fetchMonitorsForApiKey(apiKey) {
            console.log('Отправляем запрос к API для получения мониторов...');
            console.log('URL запроса:', 'https://api.uptimerobot.com/v2/getMonitors');
            console.log('API Key передан:', apiKey ? 'да' : 'нет');
            
            const response = await fetch('https://api.uptimerobot.com/v2/getMonitors', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `api_key=${encodeURIComponent(apiKey)}&format=json`
            });
            
            console.log('Получен ответ от API для получения мониторов:', response.status, response.statusText);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return await response.json();
        }
        
        // Асинхронная функция для получения всех мониторов со всех API-ключей
        async function fetchAllMonitors() {
            const allMonitors = [];
            
            for (const apiKey of apiKeys) {
                try {
                    const data = await fetchMonitorsForApiKey(apiKey);
                    console.log('Данные мониторов получены для ключа:', apiKey, data);
                    
                    // Проверяем, есть ли данные о мониторах
                    if (data.monitors && data.monitors.length > 0) {
                        // Добавляем мониторы к общему списку
                        allMonitors.push(...data.monitors);
                    }
                } catch (error) {
                    console.error('Ошибка при запросе к API для ключа', apiKey, ':', error);
                    // Продолжаем с другими ключами, даже если один из них не работает
                }
            }
            
            return allMonitors;
        }
        
        // Загружаем мониторы при загрузке страницы
        console.log('Загружаем мониторы со всех API-ключей...');
        fetchAllMonitors()
        .then(async allMonitors => {
            console.log('Все мониторы получены:', allMonitors);
            
            // Проверяем, есть ли данные о мониторах
            if (allMonitors && allMonitors.length > 0) {
                const monitorsContainer = document.getElementById('monitors-container');
                
                // Получаем временные метки для последних 24 часов
                const now = Math.floor(Date.now() / 1000);
                const yesterday = now - 86400; // 24 часа в секундах
                
                // Проходим по каждому монитору
                for (const monitor of allMonitors) {
                    console.log('Обработка монитора:', monitor);
                    
                    // Создаем элемент для отображения монитора
                    const monitorCard = document.createElement('div');
                    monitorCard.className = 'glass-card';
                    
                    // Определяем CSS класс иконки статуса в зависимости от значения поля status
                    let statusClass, statusText;
                    switch (monitor.status) {
                        case 0: // Paused
                            statusClass = 'status-paused';
                            statusText = 'Приостановлен';
                            break;
                        case 1: // Not Checked Yet
                            statusClass = 'status-not-checked';
                            statusText = 'Еще не проверялся';
                            break;
                        case 2: // Up
                            statusClass = 'status-up';
                            statusText = 'Работает';
                            break;
                        case 8: // Seems Down
                            statusClass = 'status-seems-down';
                            statusText = 'Возможно, не работает';
                            break;
                        case 9: // Down
                            statusClass = 'status-down';
                            statusText = 'Не работает';
                            break;
                        default:
                            statusClass = 'status-unknown';
                            statusText = 'Неизвестный статус';
                    }
                    
                    // Получаем исторические данные для монитора
                    try {
                        console.log('Попытка получения истории для монитора:', monitor.id);
                        // Используем первый доступный API-ключ для получения истории
                        const logs = await getMonitorHistory(apiKeys[0], monitor.id, yesterday, now);
                        
                        // Рассчитываем процент аптайма
                        let uptimePercentage = 100; // по умолчанию 100%, если нет логов
                        
                        if (logs.length > 0) {
                            console.log('Получены логи для монитора:', monitor.id, logs);
                            
                            // В логах UptimeRobot поля могут отличаться
                            // Вместо duration, используем время между логами для вычисления аптайма
                            let downtimeDuration = 0;
                            
                            // Сортируем логи по времени
                            logs.sort((a, b) => a.datetime - b.datetime);
                            
                            for (const log of logs) {
                                // Проверяем статус лога (log.type: 1=up, 2=down)
                                // В UptimeRobot: 1 - UP, 2 - DOWN
                                if (log.type === 2) { // DOWN
                                    // Если у лога есть duration, используем его
                                    if (log.duration) {
                                        downtimeDuration += log.duration;
                                    } else {
                                        // Если duration нет, вычисляем на основе времени
                                        // Временная заглушка, так как точный формат данных может отличаться
                                        console.log('Нет поля duration в логе:', log);
                                    }
                                }
                            }
                            
                            // Общее время - 24 часа в секундах
                            const totalTime = 86400;
                            uptimePercentage = ((totalTime - downtimeDuration) / totalTime) * 100;
                            
                            // Ограничиваем значение в пределах 0-10%
                            uptimePercentage = Math.max(0, Math.min(100, uptimePercentage));
                        }
                        
                        // Формируем HTML для отображения информации о мониторе
                        monitorCard.innerHTML = `
                            <div class="monitor-info">
                                <div class="monitor-header">
                                    <span class="monitor-name">${monitor.friendly_name}</span>
                                    <span class="status-indicator ${statusClass}">
                                        <span class="status-icon"></span>
                                        <span class="status-text">${statusText}</span>
                                    </span>
                                </div>
                                <div class="uptime-info">
                                    <strong>Аптайм за последние 24 часа:</strong> ${uptimePercentage.toFixed(2)}%
                                </div>
                            </div>
                        `;
                    } catch (error) {
                        console.error(`Ошибка при получении истории для монитора ${monitor.id}:`, error);
                        // В случае ошибки отображаем информацию без исторических данных
                        monitorCard.innerHTML = `
                            <div class="monitor-info">
                                <div class="monitor-header">
                                    <span class="monitor-name">${monitor.friendly_name}</span>
                                    <span class="status-indicator ${statusClass}">
                                        <span class="status-icon"></span>
                                        <span class="status-text">${statusText}</span>
                                    </span>
                                </div>
                                <div class="uptime-info">
                                    <strong>Аптайм за последние 24 часа:</strong> Не удалось загрузить историю
                                </div>
                            </div>
                        `;
                    }
                    
                    // Добавляем элемент монитора в контейнер
                    monitorsContainer.appendChild(monitorCard);
                }
            } else {
                // Если нет данных о мониторах
                console.error('Нет данных о мониторах:', allMonitors);
                alert('Не удалось получить данные о мониторах. Проверьте API Key и попробуйте снова.');
            }
        })
        .catch(error => {
            // Обрабатываем ошибки при запросе к API
            console.error('Ошибка при запросе к API для получения мониторов:', error);
            alert('Произошла ошибка при запросе к API. Проверьте API Key и попробуйте снова.');
        });
    </script>

</body>
</html>